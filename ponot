#!/usr/bin/python

import sys, os, ConfigParser, signal, subprocess, httplib, urllib

config = ConfigParser.RawConfigParser()
config.read(os.path.expanduser('~/.ponotrc'))

message = {}
message['token'] = config.get('tokens', 'api')
message['user'] = config.get('tokens', 'user')

if len(sys.argv) == 1:
    message['title'] = 'Command completed'
    message['message'] = 'Unknown status'
    code = 0
elif len(sys.argv) > 1:
    p = subprocess.Popen(sys.argv[1:])
    code = p.wait()

    signame = None
    if code < 0:
        # Figure out signal name
        for name, num in signal.__dict__.iteritems():
            if name.startswith('SIG') and not name.startswith('SIG_') and \
               num == -code:
                signame = name
                break

    message['title'] = ('Command ' + ' '.join(sys.argv[1:]))[:128]
    if code == 0:
        message['message'] = 'Finished'
    elif signame:
        message['message'] = 'Terminated by %s' % signame
    else:
        message['message'] = 'Exited with code %d' % code

conn = httplib.HTTPSConnection('api.pushover.net:443')
conn.request('POST', '/1/messages.json',
             urllib.urlencode(message),
             {'Content-type': 'application/x-www-form-urlencoded'})
res = conn.getresponse()
if res.status != 200:
    print >>sys.stderr, 'Sending notification failed:'
    print >>sys.stderr, res.read()

if code < 0:
    signal.signal(-code, signal.SIG_DFL)
    os.kill(os.getpid(), -code)
sys.exit(code)
