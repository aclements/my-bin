#!/bin/sh
# Run a command over a sequence of commits.  Based on
#   https://github.com/dustin/bindir/blob/master/git-test-sequence
# Example:
#   git test-sequence origin/master.. 'make clean && make test'

USAGE='<rev-list> <cmd>'
LONG_USAGE='Checkout each revision in <rev-list> and execute <cmd>.'
SUBDIRECTORY_OK=Yes
. "$(git --exec-path)/git-sh-setup"
require_work_tree

# Verify HEAD (from git-bisect)
head=$(GIT_DIR="$GIT_DIR" git symbolic-ref -q HEAD) ||
head=$(GIT_DIR="$GIT_DIR" git rev-parse --verify HEAD) ||
die "Bad HEAD - I need a HEAD"

_x40='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
_x40="$_x40$_x40$_x40$_x40$_x40$_x40$_x40$_x40"
case "$head" in
    refs/heads/*|$_x40)
        # This error message should only be triggered by
        # cogito usage, and cogito users should understand
        # it relates to cg-seek.
        [ -s "$GIT_DIR/head-name" ] && die "won't check out on cg-seek'ed tree"
        head="${head#refs/heads/}"
        ;;
    *)
        die "Bad HEAD - strange symbolic ref"
        ;;
esac

# Verify clean working tree
git update-index --ignore-submodules --refresh &&
git diff-files --ignore-submodules --quiet &&
git diff-index --ignore-submodules --cached --quiet HEAD -- ||
die "your working tree is not up-to-date"

cleanup() {
    git checkout -q $head
}

trap cleanup 0

revlist="$1"
shift
failed=0
prevtime=x
for v in `git rev-list --reverse $revlist`; do
    echo -n "$(git rev-list -n 1 --oneline $v) "
    tput sc

    # Ensure mtime's are updated by checkout (this is *not* enough to
    # guarantee that they'll be different from target files if the
    # command is make).
    now=$(date +%s)
    while [ x"$now" = x"$prevtime" ]; do
        sleep 1
        now=$(date +%s)
    done
    prevtime=$now
    git checkout -q $v --

    # Timer
    (
        tput cuf 999
        start=$(date +%s.%N)
        while true; do
            sleep 0.2
            now=$(date +%s.%N)
            dur=$(echo $start $now | awk '{dur=$2-$1; printf "%d:%02d", int(dur/60), int(dur%60)}')
            tput cub ${#dur}
            echo -n $dur
        done
    ) &
    timerpid=$!

    # Run command
    logfile=log.$(git rev-parse --short HEAD)
    if eval "$@" > $logfile; then
        rm $logfile
        res="PASS"; color=2
    else
        failed=`expr $failed + 1`
        res="FAIL"; color=4
    fi

    # Stop timer
    kill $timerpid
    wait $timerpid 2>/dev/null
    tput rc; tput el

    # Report status
    tput -S <<EOF
cuf 999
cub ${#res}
bold
setf $color
EOF
    echo $res
    tput sgr0
done

if [ $failed != 0 ]; then
    echo
    echo "$failed commit(s) failed. Output saved in log.<hash>."
    exit 1
fi
